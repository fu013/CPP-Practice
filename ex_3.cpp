// 10진수 -> 2진수 변환법, 10진수 -> 2진수 -> 16진수 변환법, 비트단위 논리연산자 기초

/*
#include<iostream>
using namespace std;
int main() { 
		진수 : 2진수, 8진수, 10진수, 16진수
		2진수 : 0 - 1 -> 총 2개
		8진수 : 0 - 7 -> 총 8개
		10진수 : 0 - 9 -> 총 10개
		16진수 : 0 -15 => 0 ~9 + 10~15 : a,b,c,d,e,f -> 총 16개, 이유는 만약 120이란 숫자를 표현한다고 하면, 120이 12 + 0 인지, 1 + 2 + 0 인지를 알수가 없기떄문이다.
		그래서 c+0이면 120이렇게 정의해버리면 확실하게 알수있기때문에 알파벳a-f으로 10~15를 표현한다.
		진수들은 서로 다른 진수로 변환이 가능하다.

		10진수 87을 변환해보자
		먼저 2진수, 16진수로 변환해보자.
		2진수로 변환한다. 계속 2로 나눈다.
		87 / 2 = 43 나머지 1
		43 / 2 = 21 나머지 1
		21 / 2 = 10 나머지 1
		10 / 2 = 5 나머지 0
		5 / 2 = 2 나머지 1
		2 / 2 = 1 나머지 0
		가장 마지막에 나온 몫부터 나머지들을 역순으로 읽어야 함.
		첫숫자는 몫이 나와야하므로, 마지막 몫인 1 + 010111 = 1010111
		1010111 이 된다.

		16진수를 바로 16진수로 변환하는것보다 2진수로 변환한 후에, 16진수로 변환하는 것이 쉽다.
		1010111 을 오른쪽으로부터 4자리씩 끊어서 계산한다. 16진수 1자리는 2진수 4자리이다. 8421은 16진수 BCD(Binary-Coded Decimal)코드 라고 불린다. 8+4+2+1 = 15로서 16진수에서의 최고값을 나타냄
		=> (0)101 0111            앞에 0이 하나 생략된 형태이다.
		   8421   8421
		이부분에서 1이 있는 부분만 8421에서 더해주면 된다. 앞에8421에서는 4와 1이, 오른쪽에서는 4,2,1 위에 1이 있으므로
		4+1= 5 ,  4+2+1 =7, 그리고 이 두 숫자를 문자열처럼 더해주면 "5"+"7" = 57 이게 10진수 87을 16진수로 변환한값이다.
		
		비트단위 논리연산자는 2진수단위의 연산을 한다.
		값 대 값을 연산하여 값으로 나온다. -는 틸드라고 부름
		종류 : AND(&), OR(|), NOT(-), XOR[eXclusive OR](^), 왜 exclusive or 냐면 어느한쪽만 독점할때 true라는 소리이다. 1 1 은 안되고그래서 00 도안되고 0 ,1 같은 한곳만 값이 true인 형태일때 xor도 true가 되는 것이다.
		XOR빼곤 일반 연산자와 동일한 역할
		OR은 값이 하나라도 같고, 둘다 값이 참이여도 TRUE지만
		XOR은 값이 하나만 참일때, TRUE이다 둘다 FALSE거나 둘다 TRUE값이라면 XOR은 FALSE이다. 
		그냥 하나만 제대로된 값이왔을때 참

		A B XOR
		0 0 FALSE
	    1 0 TRUE
		0 1 TRUE
		1 1 FALSE

		53/2 = 26 1
		26/2 = 13 0
		13/2 = 6 1
		6/2 = 3 0
		3/2 = 1 1
		1

		110101

		87 & 53 =
		87 : 1010111
		53 : (0)110101

		먼저 위처럼 2진수로 바꾼 후에 2진수 각 자리별로 논리연산을 실행한다.
		1010111 & 0110101
		여기서 0은 false, 1은 true를 의미한다.
		&연산자 => 0,0,1,0,1,0,1 즉, 10101이 나온다.
		10101
		=> 오른쪽부터 1,2^1,2^2,2^3,2^4
		1,4,16 해서 21
		16+4+1 = 21 즉 10진수로 표현하면 21 이다.
	int Number;
	cout << "숫자를 입력하세요.";
	cin >> Number;
	cout << Number << "&53=" << (Number & 53) << endl;
}
*/